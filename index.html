<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Genesis // Inversion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Digital Calculator & LCD Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #000000;
            color: #d1d5db;
            overflow-x: hidden;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.5); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background: rgba(0,255,255,0.3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0,255,255,0.6); }

        /* Munker-White Illusion Global Overlay - Absolute Highest Z-Index */
        .munker-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 999999;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.6) 0px,
                rgba(0, 0, 0, 0.6) 3px,
                rgba(255, 255, 255, 0.25) 3px,
                rgba(255, 255, 255, 0.25) 6px
            );
            mix-blend-mode: normal;
        }

        .glass-panel {
            background: rgba(5, 5, 10, 0.7);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: 0 4px 30px rgba(0,0,0,0.8);
        }

        .glass-sub-panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glitch-text {
            text-shadow: 2px 0 #ff00ff, -2px 0 #00ffff;
        }
        
        canvas { display: block; }
    </style>
</head>
<body class="min-h-screen p-4 flex flex-col selection:bg-cyan-900 relative text-shadow-sm">

    <!-- GLOBAL RULIAD MATRIX BACKGROUND & MUNKER ILLUSION -->
    <canvas id="globalBgCanvas" class="fixed inset-0 w-full h-full -z-10 opacity-60"></canvas>
    <div class="munker-overlay"></div>

    <!-- HEADER -->
    <header class="flex justify-between items-end border-b border-cyan-900/80 pb-2 mb-4 relative z-10 glass-panel p-4 rounded-lg">
        <div>
            <h1 class="text-3xl font-black tracking-widest text-white glitch-text">PROJECT GENESIS <span class="text-cyan-500">//</span> INVERSION</h1>
            <h2 class="text-md text-cyan-200 uppercase tracking-widest mt-1">Sim3Colts Build :: Deep Convergence v14</h2>
        </div>
        <div class="flex items-center gap-6">
            <div class="text-right text-xs text-gray-400">
                STATUS: <span class="text-yellow-400 animate-pulse font-bold" id="save-status">CONNECTING SUPABASE...</span><br/>
                BASELINE: 250,006 BOUNCES
            </div>

            <button onclick="resetEngine()" class="bg-red-500/20 border border-red-500/80 text-red-400 hover:bg-red-500 hover:text-white transition-all px-4 py-2 rounded text-[10px] font-bold tracking-widest flex items-center gap-2 shadow-[0_0_15px_rgba(255,0,0,0.2)]">
                <span>ðŸ”„</span> RESET SEARCH
            </button>

            <a href="https://buymeacoffee.com/brandonkennedy" target="_blank" rel="noopener noreferrer" 
               class="bg-yellow-500/20 border border-yellow-500/80 text-yellow-400 hover:bg-yellow-500 hover:text-black transition-all px-4 py-2 rounded text-sm font-bold tracking-widest flex items-center gap-2 shadow-[0_0_15px_rgba(255,255,0,0.4)]">
                <span>â˜•</span> TIP JAR
            </a>
        </div>
    </header>

    <!-- MAIN GRID -->
    <div class="flex-1 grid grid-cols-1 lg:grid-cols-3 gap-6 relative z-10">

        <!-- LEFT PANE: CANVAS & CONTROLS -->
        <div class="lg:col-span-2 flex flex-col gap-4">

            <div class="relative w-full h-[500px] glass-panel rounded-lg overflow-hidden shadow-[0_0_50px_rgba(0,255,255,0.15)]" id="canvas-container">
                <canvas id="simCanvas" class="absolute inset-0 w-full h-full"></canvas>
                <div class="absolute top-2 left-2 text-[11px] text-cyan-100/90 select-none pointer-events-none bg-black/80 px-2 py-1 rounded border border-cyan-900/50">
                    GEOMETRY: SQUARE_STRICT <span class="text-gray-500">+ VIRTUAL CIRCLE + VIRTUAL DIAMOND</span><br/>
                    MODE: DEEP INVERSION + EXCLUSION PHYSICS + MEMORY BOUNDS<br/>
                    <span class="text-cyan-400">7x ALPHA (CONTROL)</span> | <span class="text-magenta-400">7x BETA (OBSERVER)</span><br/>
                    EPSILON (Îµ): <span id="val-epsilon" class="text-cyan-400">0.00e+0</span>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-4 glass-panel p-4 rounded-lg text-sm">
                <div class="glass-sub-panel p-3 rounded border border-cyan-900/30">
                    <label class="flex justify-between text-cyan-100 mb-1">
                        <span>SONIC DRIVE (Time Î”t)</span>
                        <span class="text-cyan-400 font-bold" id="speedLabel">x5</span>
                    </label>
                    <input type="range" id="speedInput" min="1" max="50" value="5" class="w-full accent-cyan-500" />
                </div>
                <div class="glass-sub-panel p-3 rounded border border-magenta-900/30">
                    <label class="flex justify-between text-magenta-100 mb-1">
                        <span>SMITH MEMORY (Exclusion Cutoff)</span>
                        <span class="text-magenta-400 font-bold" id="trailLabel">200 steps</span>
                    </label>
                    <input type="range" id="trailInput" min="10" max="800" value="200" class="w-full accent-magenta-500" />
                </div>
            </div>
        </div>

        <!-- RIGHT PANE: QUADRATIC REALITY MATRIX & OBSERVABLES -->
        <div class="flex flex-col gap-4 h-full">

            <div class="glass-panel p-4 rounded-lg grid grid-cols-2 gap-y-4 gap-x-2 text-sm relative overflow-hidden">
                <div class="col-span-2 border-b border-cyan-800/80 pb-2 mb-1 text-cyan-300 font-bold tracking-widest flex justify-between text-base">
                    <span>SYSTEM MACROSTATES</span>
                    <span class="text-cyan-400 text-xs">Î” DIVERGENCE: <span id="statDivergence" class="text-white">0.000</span></span>
                </div>

                <div class="flex flex-col glass-sub-panel p-2 rounded text-center">
                    <span class="text-gray-400 text-[11px] tracking-widest uppercase">Agg. Winding ($W$)</span>
                    <span class="text-2xl text-cyan-400 font-bold mt-1" id="statWinding">0.000</span>
                </div>

                <div class="flex flex-col glass-sub-panel p-2 rounded text-center">
                    <span class="text-gray-400 text-[11px] tracking-widest uppercase">Corner Hits (Îµ)</span>
                    <span class="text-2xl text-magenta-400 font-bold mt-1" id="statCorners">0</span>
                </div>

                <div class="flex flex-col glass-sub-panel p-2 rounded text-center relative overflow-hidden">
                    <span class="text-gray-400 text-[11px] tracking-widest relative z-10 uppercase">Epoch Progress</span>
                    <span class="text-xl text-white mt-1 relative z-10" id="statBounces">0</span>
                    <div class="absolute bottom-0 left-0 h-1 bg-yellow-500 transition-all" id="flatline-progress" style="width: 0%"></div>
                </div>

                <div class="flex flex-col glass-sub-panel p-2 rounded text-center border border-lime-900/80 bg-lime-900/10">
                    <span class="text-lime-300 text-[11px] tracking-widest font-bold">SIM / INVERSION</span>
                    <span class="text-xl text-lime-400 font-bold mt-1" id="statSim">1 / FALSE</span>
                </div>
                
                <div class="flex flex-col glass-sub-panel p-2 rounded text-center border border-magenta-900/80 bg-magenta-900/10">
                    <span class="text-magenta-300 text-[10px] tracking-widest font-bold uppercase">Inversions</span>
                    <span class="text-xl text-magenta-400 font-bold mt-1" id="statInversions">0</span>
                </div>
                <div class="flex flex-col glass-sub-panel p-2 rounded text-center border border-cyan-900/80 bg-cyan-900/10">
                    <span class="text-cyan-300 text-[10px] tracking-widest font-bold uppercase">Recurrences</span>
                    <span class="text-xl text-cyan-400 font-bold mt-1" id="statRecurrences">0</span>
                </div>

                <!-- NEW: DEGREES OF FREEDOM & REALITY GAP DASHBOARD -->
                <div class="col-span-2 glass-sub-panel p-2 rounded text-center border border-purple-900/80 bg-purple-900/10 grid grid-cols-2 gap-2 mt-2">
                    <div class="flex flex-col">
                        <span class="text-purple-300 text-[9px] tracking-widest font-bold uppercase">Phase Space DoF</span>
                        <span class="text-[14px] text-purple-400 font-bold mt-1" id="statDoF">0</span>
                    </div>
                    <div class="flex flex-col">
                        <span class="text-purple-300 text-[9px] tracking-widest font-bold uppercase">Reality Gap (Î”)</span>
                        <span class="text-[14px] text-purple-400 font-bold mt-1" id="statGap">0.00e0 Sims</span>
                    </div>
                </div>

                <div class="col-span-2 flex justify-between glass-sub-panel p-2 rounded items-center border border-yellow-900/80 bg-yellow-900/10 mt-2">
                    <div class="flex flex-col text-left">
                        <span class="text-yellow-300 text-[9px] tracking-widest font-bold uppercase">Stability Analysis</span>
                        <span class="text-[10px] text-yellow-500 font-bold" id="val-variance">DEPTH: 0k / 250k | Scanning...</span>
                    </div>
                </div>
            </div>

            <div class="flex-1 flex flex-col glass-panel rounded-lg overflow-hidden min-h-[300px]">
                <div class="flex glass-sub-panel border-b border-cyan-800/80 text-xs overflow-x-auto" id="tab-headers"></div>

                <div class="flex-1 p-3 relative">
                    <div id="tab-MUSEUM" class="hidden h-full flex flex-col text-sm text-yellow-300">
                        <h3 class="text-yellow-200 mb-2 border-b border-yellow-800/80 pb-1 font-bold tracking-widest uppercase text-[10px]">Ruliad Artifacts & Epochs</h3>
                        <p class="text-[10px] text-gray-400 mb-2 uppercase">Preserving Speed-Invariant symmetries and Re-emergences.</p>
                        <div class="flex-1 overflow-y-auto space-y-2 pr-2" id="museum-gallery"></div>
                    </div>

                    <div id="tab-STRUCTURE_RATIO" class="hidden h-full flex flex-col text-sm text-purple-300">
                        <h3 class="text-purple-200 mb-2 border-b border-purple-800/80 pb-1 font-bold tracking-widest uppercase">Morphological Ratio (Î¦)</h3>
                        <div class="flex-1 flex flex-col gap-2">
                            <div class="glass-sub-panel p-2 rounded grid grid-cols-3 gap-2 text-center text-xs">
                                <div><span class="text-gray-400 text-[10px]">STRUCTURED</span><br><span id="val-structured" class="text-lime-400 font-bold">0</span></div>
                                <div><span class="text-gray-400 text-[10px]">RATIO (Î¦)</span><br><span id="val-ratio-current" class="text-purple-400 font-bold text-lg">0.000</span></div>
                                <div><span class="text-gray-400 text-[10px]">CHAOTIC</span><br><span id="val-chaotic" class="text-red-400 font-bold">0</span></div>
                            </div>
                            <div class="mt-1 text-center text-[10px] font-bold tracking-widest text-cyan-500 bg-black/50 p-1 rounded border border-cyan-900/50" id="chaos-trend">EMERGENCE TREND: SCANNING...</div>
                            <div class="flex-1 relative glass-sub-panel rounded overflow-hidden mt-1">
                                <canvas id="ratioCanvas" class="absolute inset-0 w-full h-full opacity-90"></canvas>
                            </div>
                        </div>
                    </div>

                    <div id="tab-SUPER_BRAIN" class="hidden h-full flex flex-col text-sm text-blue-200">
                        <h3 class="text-blue-300 mb-2 border-b border-blue-800/80 pb-1 font-bold tracking-widest uppercase">Hive-Mind Registry</h3>
                        <div class="flex-1 overflow-y-auto space-y-3 pr-2">
                            <div class="glass-sub-panel border-lime-900/80 p-2 rounded bg-lime-900/10">
                                <p class="text-lime-400 font-bold mb-1 tracking-widest">VIRTUAL TOPOLOGIES</p>
                                <div class="flex justify-between"><span class="text-gray-300">Virtual Circle Hits:</span> <span id="virt-circle" class="text-lime-300 font-bold">0</span></div>
                                <div class="flex justify-between mt-1"><span class="text-gray-300">Virtual Diamond:</span> <span id="virt-diamond" class="text-lime-300 font-bold">0</span></div>
                            </div>
                            <div class="glass-sub-panel border-blue-900/80 p-2 rounded">
                                <p class="text-blue-400 font-bold mb-1 tracking-widest">SWARM VARIANTS</p>
                                <div id="swarm-divergence-bars" class="space-y-1"></div>
                            </div>
                            <div class="glass-sub-panel border-blue-900/80 p-2 rounded">
                                <p class="text-blue-400 font-bold mb-1 tracking-widest">VOID DETECTION</p>
                                <div class="flex justify-between"><span class="text-gray-300">Shared Caustic Radius:</span> <span id="super-void" class="text-cyan-400 font-bold">0.000</span></div>
                            </div>
                        </div>
                    </div>

                    <div id="tab-EYES" class="hidden h-full flex flex-col text-sm text-blue-400">
                        <h3 class="text-blue-200 mb-2 border-b border-blue-800/80 pb-1 font-bold tracking-widest uppercase text-[10px]">Collective Eye Map</h3>
                        <div class="flex-1 relative glass-sub-panel overflow-hidden rounded">
                            <canvas id="eyesCanvas" class="absolute inset-0 w-full h-full opacity-100"></canvas>
                        </div>
                    </div>

                    <div id="tab-STABILITY" class="hidden h-full flex flex-col text-sm text-indigo-300">
                        <h3 class="text-indigo-200 mb-2 border-b border-indigo-800/80 pb-1 font-bold tracking-widest uppercase">Orbital Variance</h3>
                        <div class="flex-1 overflow-y-auto space-y-2 pr-2" id="stability-log">
                            <div class="text-gray-400">Syncing period logs...</div>
                        </div>
                    </div>

                    <div id="tab-VOIDS" class="hidden h-full flex flex-col text-sm text-teal-300">
                        <h3 class="text-teal-200 mb-2 border-b border-teal-800/80 pb-1 font-bold tracking-widest uppercase">Caustic Convergence</h3>
                        <div class="grid grid-cols-2 gap-2 mb-2">
                            <div class="glass-sub-panel p-2 rounded">
                                <p class="text-gray-400 text-xs">Inst. Radius</p>
                                <p class="text-teal-400 font-bold text-xl" id="void-radius">0.000</p>
                            </div>
                        </div>
                        <div class="flex-1 relative glass-sub-panel rounded overflow-hidden">
                            <canvas id="causticCanvas" class="absolute inset-0 w-full h-full opacity-90"></canvas>
                        </div>
                    </div>

                    <div id="tab-HYPER" class="hidden h-full flex flex-col text-sm text-cyan-300">
                        <h3 class="text-cyan-200 mb-2 border-b border-cyan-800/80 pb-1 font-bold tracking-widest uppercase">Dimensionality</h3>
                        <div class="flex-1 grid grid-cols-2 gap-4">
                            <div class="glass-sub-panel p-2 rounded h-min">
                                <p class="text-gray-400 text-xs text-lime-400">Effective Dim $d$</p>
                                <p class="text-2xl text-lime-400 font-bold" id="hyper-dim">1.0000</p>
                            </div>
                            <div class="col-span-2 mt-2 flex-1 flex flex-col">
                                <p class="text-gray-300 mb-1 text-xs uppercase font-bold tracking-widest">Phase-Space PoincarÃ© Map</p>
                                <div class="w-full flex-1 glass-sub-panel relative overflow-hidden rounded shadow-inner min-h-[100px]">
                                    <canvas id="hyperCanvas" class="absolute inset-0 w-full h-full opacity-100"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="tab-ZETA" class="hidden h-full flex flex-col text-sm text-magenta-300">
                        <h3 class="text-magenta-200 mb-2 border-b border-magenta-800/80 pb-1 font-bold tracking-widest uppercase">Blade algorithmic heuristics</h3>
                        <div class="grid grid-cols-2 gap-4 mb-2">
                            <div class="glass-sub-panel p-2 rounded">
                                <p class="text-gray-400 text-xs text-cyan-400 uppercase font-bold tracking-widest">High Zeta (> 0.5)</p>
                                <p class="text-xl text-cyan-400 font-bold" id="zeta-high">0</p>
                            </div>
                            <div class="glass-sub-panel p-2 rounded">
                                <p class="text-gray-400 text-xs text-red-400 uppercase font-bold tracking-widest">Low Zeta (< 0.5)</p>
                                <p class="text-xl text-red-400 font-bold" id="zeta-low">0</p>
                            </div>
                        </div>
                        <div class="flex-1 relative glass-sub-panel rounded overflow-hidden">
                            <canvas id="zetaCanvas" class="absolute inset-0 w-full h-full opacity-100"></canvas>
                        </div>
                    </div>

                    <div id="tab-RANK" class="hidden h-full flex flex-col text-sm text-emerald-300">
                        <h3 class="text-emerald-200 mb-2 border-b border-emerald-800/80 pb-1 font-bold tracking-widest uppercase">Global Rank (Total Compute)</h3>
                        <div class="flex justify-between text-[11px] text-gray-400 mb-2 px-1">
                            <span>RANK / UID</span>
                            <span>COMPUTE (BNCS)</span>
                        </div>
                        <div id="leaderboard-container" class="flex-1 overflow-y-auto space-y-1 pr-2"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ARTIFACT RENDER MODAL -->
    <div id="artifactModal" class="fixed inset-0 z-[90000] hidden items-center justify-center p-8 bg-black/80 backdrop-blur-md">
        <div class="glass-panel w-full max-w-5xl h-[85vh] flex flex-col rounded-xl shadow-[0_0_100px_rgba(0,255,255,0.4)] overflow-hidden border-2 border-cyan-500">
            <div class="bg-gray-900/90 border-b border-cyan-500 p-4 flex justify-between items-center">
                <h2 class="text-cyan-400 font-bold tracking-widest text-xl glitch-text" id="modal-title">ARTIFACT RENDER</h2>
                <button onclick="closeModal()" class="text-red-500 hover:text-red-300 text-3xl font-bold px-2 transition-colors leading-none">&times;</button>
            </div>
            <div class="flex-1 grid grid-cols-2 p-4 gap-4 bg-black/60 relative" id="modal-canvases-container">
                <div class="flex flex-col glass-sub-panel rounded-lg relative overflow-hidden shadow-inner">
                    <div class="absolute top-0 left-0 right-0 bg-black/90 border-b border-cyan-800/80 p-2 z-10 text-center text-xs text-cyan-300 font-bold flex justify-between px-4 tracking-widest">
                        <span>2D TRAJECTORY SPACE</span>
                        <span class="text-yellow-400 animate-pulse uppercase">200X RECONSTRUCTION</span>
                    </div>
                    <canvas id="modalTrajCanvas" class="w-full h-full"></canvas>
                </div>
                <div class="flex flex-col glass-sub-panel rounded-lg relative overflow-hidden shadow-inner">
                    <div class="absolute top-0 left-0 right-0 bg-black/90 border-b border-magenta-800/80 p-2 z-10 text-center text-xs text-magenta-300 font-bold tracking-widest uppercase">Ruliad Generation</div>
                    <canvas id="modalRuliadCanvas" class="w-full h-full"></canvas>
                </div>
            </div>
            <div class="bg-gray-900/90 p-4 border-t border-cyan-500 text-sm text-gray-300 leading-relaxed font-mono overflow-y-auto" id="modal-desc"></div>
        </div>
    </div>

    <!-- ENGINE SCRIPT -->
    <script>
        // --- GLOBAL INITIALIZATION ---
        const BOX_SIZE = 1;
        const CORNER_TOLERANCE = 0.05;
        const INITIAL_SPEED = 0.015;
        const NUM_SWARMS = 7;
        const flatlineBaseline = 250006; 
        const PARTICLE_RADIUS = 0.025; // Pauli Exclusion Radius

        // Global State Collections
        let fleet = [];
        let artifacts = [];
        let epochSignatures = [];
        let initialFleetState = [];
        let ratioHistory = [];
        let speedHistory = [];
        let causticHistory = [];
        let recentRadii = [];
        let visitedGrid = new Map();
        let hyperGrid = new Map();

        // Tracker State
        let simCount = 1;
        let epochBounces = 0;
        let isEpochInverted = false;
        let baseAngleShift = 0;
        let lastKamBounce = 0;
        let structuredEvents = 0;
        let chaoticEvents = 0;
        let currentTickCaustic = Infinity;
        let inversionIncidences = 0;
        let reEmergenceCount = 0;
        let firstRunRatio = null;
        let globalTick = 0;
        let stats = { bounces: 0, cornerHits: 0, windingNumber: 0 };
        let zetaStats = { high: 0, low: 0 };
        let activeTab = 'STRUCTURE_RATIO';
        let speed = 5;
        let maxAllowedSpeed = 50; // Dynamic Overclocking threshold
        let trailLength = 200;
        let stabilityHistory = [];
        let stabilityLogArray = [];
        let globalLeaderboard = [];
        let virtualHits = { circle: 0, diamond: 0 };

        // CA Background State
        let bgCols = 0, bgRows = 0, bgGridCA = [];
        const colorMapPalette = ['#ffffff', '#00ffff', '#00ff88', '#ffff00', '#ff8800', '#ff00ff', '#220044'];

        let supabaseClient, currentUser, isSaving = false, lastSaveBounce = 0, lastSaveTime = 0;
        let frameCount = 0;
        let lastFpsTime = performance.now();

        // --- MATH ENGINE & SYMMETRY ---
        function getHyperPrecisionZeta(baseNum, x, y) {
            let str = baseNum.toFixed(15);
            let seed = Math.abs(Math.floor(x * 1e7) ^ Math.floor(y * 1e7)) || 123456789;
            while(str.length < 103) { 
                seed = (seed * 9301 + 49297) % 233280; 
                str += Math.floor((seed/233280) * 1e10).toString().padStart(10, '0');
            }
            return str.substring(0, 103);
        }

        function calculateTemporalSensitivity() {
            if (speedHistory.length === 0) return { mean: speed, stability: 100 };
            const n = speedHistory.length;
            const mean = speedHistory.reduce((a, b) => a + b, 0) / n;
            const variance = speedHistory.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
            const stability = Math.max(0, 100 - (Math.sqrt(variance) / (mean || 1)) * 100);
            return { mean: mean.toFixed(2), stability: parseFloat(stability.toFixed(1)) };
        }

        function generateSwarmSignature() {
            let cx = 0, cy = 0, lz = 0;
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            fleet.forEach(g => {
                const a = g.alpha; cx += a.x; cy += a.y;
                if (a.x < minX) minX = a.x; if (a.x > maxX) maxX = a.x;
                if (a.y < minY) minY = a.y; if (a.y > maxY) maxY = a.y;
            });
            cx /= fleet.length; cy /= fleet.length;
            fleet.forEach(g => {
                const a = g.alpha; const rx = a.x - cx, ry = a.y - cy;
                lz += (rx * a.vy - ry * a.vx);
            });
            return { id: `EPOCH-${simCount}`, cx, cy, lz, bounds: { minX, maxX, minY, maxY } };
        }

        function checkInversionIncidence() {
            if (epochSignatures.length === 0) return false;
            const cur = generateSwarmSignature();
            for (let past of epochSignatures) {
                if (Math.abs(cur.lz + past.lz) < 0.05 && Math.abs(cur.lz) > 0.01) {
                    return { matchedEpoch: past.id, type: "MOMENTUM_REVERSAL" };
                }
            }
            return false;
        }

        function checkReEmergence() {
            if (!initialFleetState || initialFleetState.length === 0) return false;
            let drift = 0;
            for (let i = 0; i < fleet.length; i++) {
                drift += Math.sqrt(
                    Math.pow(fleet[i].alpha.x - initialFleetState[i].alpha.x, 2) + 
                    Math.pow(fleet[i].alpha.y - initialFleetState[i].alpha.y, 2) +
                    Math.pow(fleet[i].alpha.vx - initialFleetState[i].alpha.vx, 2) +
                    Math.pow(fleet[i].alpha.vy - initialFleetState[i].alpha.vy, 2)
                );
                if (drift > 1e-9) return false;
            }
            return true;
        }

        function initializeFleet(angleShift, invertBasis = false) {
            const multiplier = invertBasis ? -1 : 1;
            const newFleet = Array.from({ length: NUM_SWARMS }, (_, i) => {
                const angle = (i / NUM_SWARMS) * Math.PI * 2 + angleShift;
                const sx = Math.cos(angle) * 0.3 * multiplier, sy = Math.sin(angle) * 0.3 * multiplier;
                const vx = Math.cos(angle + Math.PI/4) * INITIAL_SPEED * multiplier, vy = Math.sin(angle + Math.PI/4) * INITIAL_SPEED * multiplier;
                
                // Offset Beta slightly so it doesn't violate the Pauli exclusion principle at spawn
                const betaOffset = PARTICLE_RADIUS * 2.1;

                return {
                    id: i,
                    alpha: { x: sx, y: sy, prevX: sx, prevY: sy, vx, vy, theta: angle, accumulatedTheta: 0, trail: [] },
                    beta:  { x: sx + betaOffset, y: sy, prevX: sx + betaOffset, prevY: sy, vx, vy, theta: angle, accumulatedTheta: 0, trail: [] },
                    divergence: 0, bounces: 0
                };
            });
            // Snapshot baseline for Re-emergence logic
            initialFleetState = newFleet.map(g => ({
                alpha: { x: g.alpha.x, y: g.alpha.y, vx: g.alpha.vx, vy: g.alpha.vy },
                beta: { x: g.beta.x, y: g.beta.y, vx: g.beta.vx, vy: g.beta.vy }
            }));
            return newFleet;
        }

        fleet = initializeFleet(baseAngleShift, isEpochInverted);

        // --- CA BACKGROUND ENGINE (The 7-State Ruliad) ---
        function initBgGrid(w, h) {
            bgCols = Math.ceil(w / 25); bgRows = Math.ceil(h / 25);
            bgGridCA = new Array(bgCols).fill(0).map(() => new Array(bgRows).fill(0).map(() => Math.floor(Math.random() * 7)));
        }

        function updateBgGrid() {
            if (bgGridCA.length === 0) return;
            let n = new Array(bgCols).fill(0).map(() => new Array(bgRows).fill(0));
            for (let x = 0; x < bgCols; x++) {
                for (let y = 0; y < bgRows; y++) {
                    let s = bgGridCA[x][y], nxS = (s + 1) % 7, ch = false;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            let nx = (x + dx + bgCols) % bgCols, ny = (y + dy + bgRows) % bgRows;
                            if (bgGridCA[nx][ny] === nxS) { ch = true; break; }
                        }
                        if (ch) break;
                    }
                    n[x][y] = ch ? nxS : s;
                }
            }
            bgGridCA = n;
        }

        // --- UNIFIED RENDERING HELPER ---
        // Maps continuous age gradients into the 7 discrete states of the Ruliad
        function getRuliadColorState(age, maxAge = 2400) {
            if (age < 5) return colorMapPalette[0];                  
            if (age < maxAge * 0.02) return colorMapPalette[1];      
            if (age < maxAge * 0.05) return colorMapPalette[2];      
            if (age < maxAge * 0.12) return colorMapPalette[3];      
            if (age < maxAge * 0.25) return colorMapPalette[4];      
            if (age < maxAge * 0.60) return colorMapPalette[5];      
            return colorMapPalette[6];                               
        }

        // --- DYNAMIC CANVAS AUTO-RESIZER ---
        function ensureCanvasSize(id) {
            const c = document.getElementById(id);
            if (!c || !c.parentElement) return null;
            const w = c.parentElement.clientWidth;
            const h = c.parentElement.clientHeight;
            if (w === 0 || h === 0) return null;
            if (c.width !== w || c.height !== h) { c.width = w; c.height = h; }
            return c;
        }

        function renderMuseum() {
            const c = document.getElementById('museum-gallery');
            if (activeTab !== 'MUSEUM' || !c) return;
            const currentArtifacts = artifacts || [];
            if (currentArtifacts.length === 0) { 
                c.innerHTML = '<div class="text-gray-600 text-center mt-10 uppercase text-[10px] tracking-widest font-bold border border-cyan-900/20 p-4">Awaiting Deep Thermalization (250k)...</div>'; 
                return; 
            }
            c.innerHTML = currentArtifacts.map(a => {
                const isE = a.id.includes('EPOCH'), isR = a.id.includes('RECURRENCE'), isI = a.id.includes('INVERSION');
                let border = 'border-yellow-500 bg-yellow-900/10';
                let color = 'text-yellow-400';
                if(isE) { border = 'border-lime-500 bg-lime-900/10 shadow-[0_0_15px_rgba(0,255,0,0.1)]'; color = 'text-lime-400'; }
                if(isR) { border = 'border-emerald-500 bg-emerald-900/10 shadow-[0_0_15px_rgba(0,255,128,0.1)]'; color = 'text-emerald-400'; }
                if(isI) { border = 'border-magenta-500 bg-magenta-900/10 shadow-[0_0_15px_rgba(255,0,255,0.1)]'; color = 'text-magenta-400'; }
                
                return `<div onclick="openArtifactModal('${a.id}')" class="cursor-pointer glass-sub-panel p-3 rounded border-l-2 ${border} mb-2 hover:bg-white/5 transition-all">
                    <div class="flex justify-between font-bold text-[11px] uppercase border-b pb-1 mb-1 border-white/10">
                        <span class="${color}">${a.id}</span>
                        <span>BNCS: ${a.bounce.toLocaleString()}</span>
                    </div>
                    <div class="text-[10px] text-gray-300 leading-relaxed">${a.desc}</div>
                </div>`;
            }).join('');
        }

        function renderActiveTabCanvases() {
            if (activeTab === 'STRUCTURE_RATIO') {
                const c = ensureCanvasSize('ratioCanvas');
                if (c) {
                    const rCtx = c.getContext('2d'); rCtx.clearRect(0,0,c.width,c.height);
                    if (ratioHistory.length > 1) {
                        const max = Math.max(...ratioHistory, 1.618); rCtx.beginPath();
                        ratioHistory.forEach((r, i) => { const x = (i/300)*c.width, y = c.height - (r/max)*c.height; if(i===0) rCtx.moveTo(x,y); else rCtx.lineTo(x,y); });
                        rCtx.strokeStyle = '#ff00ff'; rCtx.lineWidth = 2; rCtx.stroke();
                    }
                }
            }
            if (activeTab === 'EYES') {
                const c = ensureCanvasSize('eyesCanvas');
                if (c) {
                    const eCtx = c.getContext('2d'); eCtx.clearRect(0, 0, c.width, c.height);
                    const ew = c.width, eh = c.height, gridSize = 40, cellW = ew/gridSize, cellH = eh/gridSize;
                    visitedGrid.forEach((cell, key) => {
                        const parts = key.split(',');
                        const gx = parseInt(parts[0]), gy = parseInt(parts[1]);
                        let displayAge = globalTick - cell.lastVisit;
                        if (cell.density > 2) {
                            const timeMod = Math.floor(globalTick * 0.15); 
                            const magicHash = (gx ^ gy ^ timeMod) % 25;
                            if (magicHash === 0) displayAge = 2; 
                            else if (magicHash < 3) displayAge = 40; 
                            else if (cell.density > 8 && (gx * gy + timeMod) % 15 === 0) displayAge = 200; 
                        }
                        eCtx.fillStyle = getRuliadColorState(displayAge);
                        eCtx.fillRect((gx/gridSize)*ew, (gy/gridSize)*eh, cellW - 1, cellH - 1);
                    });
                }
            }
            if (activeTab === 'HYPER') {
                const c = ensureCanvasSize('hyperCanvas');
                if (c) {
                    const hCtx = c.getContext('2d'); hCtx.clearRect(0, 0, c.width, c.height);
                    const hw = c.width, hh = c.height, hCellW = hw/40, hCellH = hh/40;
                    hyperGrid.forEach((cell, key) => {
                        const parts = key.split(',');
                        const gx = parseInt(parts[0]), gy = parseInt(parts[1]);
                        hCtx.fillStyle = getRuliadColorState(globalTick - cell.lastVisit);
                        hCtx.fillRect((gx/40)*hw, (gy/40)*hh, hCellW - 1, hCellH - 1);
                    });
                    const dEl = document.getElementById('hyper-dim');
                    if (dEl) dEl.innerText = (1.0 + Math.abs(stats.windingNumber * 0.0142)).toFixed(4);
                }
            }
            if (activeTab === 'ZETA') {
                const c = ensureCanvasSize('zetaCanvas');
                if (c) {
                    const zCtx = c.getContext('2d'); zCtx.clearRect(0, 0, c.width, c.height);
                    const zw = c.width, zh = c.height, zCellW = zw/8, zCellH = zh/8;
                    for (let ix = 0; ix < 8; ix++) {
                        for (let iy = 0; iy < 8; iy++) {
                            const weight = Math.abs(Math.sin((ix+1) * fleet[0].beta.x * 3.14 + (iy+1) * fleet[0].beta.y * 2.71 + globalTick * 0.005));
                            zCtx.fillStyle = getRuliadColorState((1.0 - weight) * 2400);
                            zCtx.fillRect((ix/8)*zw, (iy/8)*zh, zCellW - 1, zCellH - 1);
                        }
                    }
                    const zhEl = document.getElementById('zeta-high'); if (zhEl) zhEl.innerText = zetaStats.high.toLocaleString();
                    const zlEl = document.getElementById('zeta-low'); if (zlEl) zlEl.innerText = zetaStats.low.toLocaleString();
                }
            }
            if (activeTab === 'VOIDS') {
                const c = ensureCanvasSize('causticCanvas');
                if (c) {
                    const cCtx = c.getContext('2d'); cCtx.clearRect(0, 0, c.width, c.height);
                    if (causticHistory.length > 1) {
                        cCtx.beginPath();
                        for (let i=0; i<causticHistory.length; i++) {
                            const x = (i / 300) * c.width;
                            const y = c.height - (causticHistory[i] / 1.414) * c.height; 
                            if (i===0) cCtx.moveTo(x, y); else cCtx.lineTo(x, y);
                        }
                        cCtx.strokeStyle = '#00ffff'; cCtx.lineWidth = 2; cCtx.stroke();
                        cCtx.lineTo(c.width, c.height); cCtx.lineTo(0, c.height);
                        const grad = cCtx.createLinearGradient(0,0,0,c.height);
                        grad.addColorStop(0, 'rgba(0,255,255,0.4)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
                        cCtx.fillStyle = grad; cCtx.fill();
                    }
                    const vr = document.getElementById('void-radius');
                    if (vr) vr.innerText = currentTickCaustic === Infinity ? '1.414' : currentTickCaustic.toFixed(4);
                }
            }
            if (activeTab === 'SUPER_BRAIN') {
                const el = document.getElementById('super-void'); if (el) el.innerText = currentTickCaustic === Infinity ? '1.414' : currentTickCaustic.toFixed(4);
                const vc = document.getElementById('virt-circle'); if (vc) vc.innerText = virtualHits.circle.toLocaleString();
                const vd = document.getElementById('virt-diamond'); if (vd) vd.innerText = virtualHits.diamond.toLocaleString();
                const sb = document.getElementById('swarm-divergence-bars');
                if (sb) {
                    sb.innerHTML = fleet.map(g => `
                        <div class="flex items-center gap-2 mb-1">
                            <span class="text-[10px] w-12 text-gray-400">SWRM ${g.id+1}</span>
                            <div class="flex-1 bg-black/50 h-2 rounded border border-gray-700"><div class="bg-cyan-400 h-full transition-all" style="width: ${Math.min(100, g.divergence * 50)}%; box-shadow: 0 0 10px rgba(0,255,255,0.8);"></div></div>
                            <span class="text-[10px] text-cyan-200 w-10 text-right">${g.divergence.toFixed(3)}</span>
                        </div>
                    `).join('');
                }
            }
        }

        // --- PHYSICS CALCULATION ---
        function updatePhysics() {
            let swarmHit = false, maxDiv = 0;
            for (let step = 0; step < speed; step++) {
                globalTick++;
                if (globalTick % 100 === 0) speedHistory.push(speed);

                let allAgents = [];

                // Phase 1: Boundary Interactions (Factoring Particle Radius)
                fleet.forEach(g => {
                    [g.alpha, g.beta].forEach((a, idx) => {
                        a.prevX = a.x; a.prevY = a.y;
                        let nx = a.x + a.vx, ny = a.y + a.vy, b = false;
                        
                        if (nx > BOX_SIZE - PARTICLE_RADIUS) { a.vx *= -1; b = true; nx = BOX_SIZE - PARTICLE_RADIUS; }
                        if (nx < -BOX_SIZE + PARTICLE_RADIUS) { a.vx *= -1; b = true; nx = -BOX_SIZE + PARTICLE_RADIUS; }
                        if (ny > BOX_SIZE - PARTICLE_RADIUS) { a.vy *= -1; b = true; ny = BOX_SIZE - PARTICLE_RADIUS; }
                        if (ny < -BOX_SIZE + PARTICLE_RADIUS) { a.vy *= -1; b = true; ny = -BOX_SIZE + PARTICLE_RADIUS; }
                        
                        if (b && idx === 0) { 
                            swarmHit = true; stats.bounces++; epochBounces++; 
                            if (Math.abs(nx) > BOX_SIZE - PARTICLE_RADIUS - CORNER_TOLERANCE && Math.abs(ny) > BOX_SIZE - PARTICLE_RADIUS - CORNER_TOLERANCE) { 
                                stats.cornerHits++; 
                                structuredEvents++; 
                            } 
                            // Phase-Space Poincare logging
                            let ht = Math.atan2(ny, nx);
                            const hyperX = Math.floor((nx + BOX_SIZE) * 20); 
                            const hyperTheta = Math.floor(((ht + Math.PI) / (2 * Math.PI)) * 40); 
                            hyperGrid.set(`${hyperX},${hyperTheta}`, { density: 1, lastVisit: globalTick });
                        }

                        const prevR2 = a.prevX*a.prevX + a.prevY*a.prevY;
                        const nextR2 = nx*nx + ny*ny;
                        if (prevR2 < 1 && nextR2 >= 1) virtualHits.circle++;
                        const prevD = Math.abs(a.prevX) + Math.abs(a.prevY);
                        const nextD = Math.abs(nx) + Math.abs(ny);
                        if (prevD < 1 && nextD >= 1) virtualHits.diamond++;
                        
                        let nt = Math.atan2(ny, nx), dt = nt - a.theta;
                        if (dt > Math.PI) dt -= 2*Math.PI; if (dt < -Math.PI) dt += 2*Math.PI;
                        a.accumulatedTheta += dt; a.theta = nt;
                        a.x = nx; a.y = ny;
                        allAgents.push(a);
                    });
                });

                // Phase 2: O(N^2) Perfectly Elastic Particle Collisions (Pauli Exclusion)
                for (let i = 0; i < allAgents.length; i++) {
                    for (let j = i + 1; j < allAgents.length; j++) {
                        let p1 = allAgents[i];
                        let p2 = allAgents[j];
                        let dx = p2.x - p1.x;
                        let dy = p2.y - p1.y;
                        let distSq = dx * dx + dy * dy;
                        let minDist = PARTICLE_RADIUS * 2;

                        if (distSq < minDist * minDist) {
                            if (distSq === 0) { dx = 0.0001; dy = 0; distSq = 0.00000001; } 
                            let dist = Math.sqrt(distSq);
                            let nx = dx / dist;
                            let ny = dy / dist;

                            let overlap = minDist - dist;
                            p1.x -= nx * (overlap / 2);
                            p1.y -= ny * (overlap / 2);
                            p2.x += nx * (overlap / 2);
                            p2.y += ny * (overlap / 2);

                            let dvx = p1.vx - p2.vx;
                            let dvy = p1.vy - p2.vy;
                            let vn = dvx * nx + dvy * ny;

                            if (vn > 0) { 
                                p1.vx -= vn * nx; p1.vy -= vn * ny;
                                p2.vx += vn * nx; p2.vy += vn * ny;
                            }
                        }
                    }
                }

                // Phase 2.5: MEMORY EXCLUSION PRINCIPLE (Observer Beta interacts with Alpha memory boundary)
                // We sample the trail every 10 steps to maintain 60fps performance while creating a massive interference web
                fleet.forEach(g => {
                    let betaAgent = g.beta;
                    fleet.forEach(otherG => {
                        let targetTrail = otherG.alpha.trail;
                        for(let k = targetTrail.length - 1; k >= 0 && k >= targetTrail.length - trailLength; k -= 10) {
                            let tPoint = targetTrail[k];
                            let dx = tPoint.x - betaAgent.x;
                            let dy = tPoint.y - betaAgent.y;
                            let distSq = dx*dx + dy*dy;
                            let memRadius = PARTICLE_RADIUS * 1.5; // Soft memory boundary
                            
                            if(distSq < memRadius*memRadius && distSq > 0.00001) {
                                let dist = Math.sqrt(distSq);
                                let nx = dx / dist;
                                let ny = dy / dist;
                                
                                // Soft deflection from the memory ghost
                                let currentV = Math.sqrt(betaAgent.vx*betaAgent.vx + betaAgent.vy*betaAgent.vy);
                                betaAgent.vx -= nx * 0.005; 
                                betaAgent.vy -= ny * 0.005;
                                
                                // Normalize back to initial speed to conserve momentum
                                let newV = Math.sqrt(betaAgent.vx*betaAgent.vx + betaAgent.vy*betaAgent.vy);
                                betaAgent.vx = (betaAgent.vx / newV) * currentV;
                                betaAgent.vy = (betaAgent.vy / newV) * currentV;
                            }
                        }
                    });
                });

                // Phase 3: Post-Collision Updating
                fleet.forEach(g => {
                    [g.alpha, g.beta].forEach((a, idx) => {
                        a.trail.push({ x: a.x, y: a.y, tick: globalTick });
                        if (a.trail.length > trailLength) a.trail.shift();

                        const gx = Math.floor((a.x + BOX_SIZE) * 20), gy = Math.floor((a.y + BOX_SIZE) * 20);
                        const k = `${gx},${gy}`;
                        const c = visitedGrid.get(k) || { density: 0, lastVisit: 0 };
                        visitedGrid.set(k, { density: c.density + 1, lastVisit: globalTick });

                        let baseZeta = Math.max(0.0, 1.0 - (c.density / 15.0));
                        let fracX = Math.abs((a.x + BOX_SIZE) * 20 - gx - 0.5); 
                        let fracY = Math.abs((a.y + BOX_SIZE) * 20 - gy - 0.5);
                        let microVariance = (0.5 - fracX) * (0.5 - fracY) * 0.39996; 
                        let currentZetaNum = baseZeta > 0 ? Math.min(1.0, baseZeta + microVariance) : 0;
                        if (currentZetaNum >= 0.5) zetaStats.high++; else zetaStats.low++;
                    });
                    
                    g.divergence = Math.sqrt(Math.pow(g.alpha.x - g.beta.x, 2) + Math.pow(g.alpha.y - g.beta.y, 2));
                    if (g.divergence > maxDiv) maxDiv = g.divergence;
                    if (g.divergence > 0.3) chaoticEvents++;

                    const rAlpha = Math.sqrt(g.alpha.x**2 + g.alpha.y**2);
                    const rBeta = Math.sqrt(g.beta.x**2 + g.beta.y**2);
                    recentRadii.push(Math.min(rAlpha, rBeta));
                    if (recentRadii.length > 300) recentRadii.shift();
                    currentTickCaustic = Math.min(...recentRadii);
                });

                let curRatio = chaoticEvents === 0 ? structuredEvents : structuredEvents / chaoticEvents;
                if (globalTick % 20 === 0) { ratioHistory.push(curRatio); if (ratioHistory.length > 300) ratioHistory.shift(); }
                if (globalTick % 50 === 0) { causticHistory.push(currentTickCaustic === Infinity ? 1.414 : currentTickCaustic); if (causticHistory.length > 300) causticHistory.shift(); }

                if (epochBounces > 5000 && checkReEmergence()) {
                    reEmergenceCount++;
                    const drift = firstRunRatio !== null ? (curRatio - firstRunRatio).toFixed(5) : "Awaiting Baseline";
                    artifacts.unshift({ id: `RECURRENCE-${simCount}-${reEmergenceCount}`, bounce: stats.bounces, tick: globalTick, desc: `POINCARÃ‰ RE-EMERGENCE: System returned to t=0 phase-space.<br/>Drift Î”Î¦: ${drift}`, trailAlpha: [...fleet[0].alpha.trail], trailBeta: [...fleet[0].beta.trail], kinematics: { alpha: {...fleet[0].alpha}, beta: {...fleet[0].beta} } });
                    if (artifacts.length > 25) { const idx = artifacts.findIndex(a => !a.id.includes('EPOCH') && !a.id.includes('RECURRENCE')); if (idx !== -1) artifacts.splice(idx, 1); else artifacts.pop(); }
                    epochBounces = 0;
                }

                if (epochBounces > 0 && epochBounces % 2000 === 0) {
                    const inv = checkInversionIncidence();
                    if (inv) {
                        inversionIncidences++;
                        artifacts.unshift({ id: `INVERSION-${simCount}-${inversionIncidences}`, bounce: stats.bounces, tick: globalTick, desc: `GEOMETRIC INVERSION: Mirrors ${inv.matchedEpoch}.<br/>Type: <span class="text-magenta-400 font-bold">${inv.type}</span>`, trailAlpha: [...fleet[0].alpha.trail], trailBeta: [...fleet[0].beta.trail], kinematics: { alpha: {...fleet[0].alpha}, beta: {...fleet[0].beta} } });
                        if (artifacts.length > 25) { const idx = artifacts.findIndex(a => !a.id.includes('EPOCH') && !a.id.includes('INVERSION')); if (idx !== -1) artifacts.splice(idx, 1); else artifacts.pop(); }
                    }
                }

                if (epochBounces > flatlineBaseline && ratioHistory.length >= 300) {
                    const mean = ratioHistory.reduce((a,b)=>a+b,0) / ratioHistory.length;
                    const variance = ratioHistory.reduce((a,b)=>a+Math.pow(b-mean,2),0) / ratioHistory.length;
                    if (variance < 1e-10) {
                        const sens = calculateTemporalSensitivity();
                        if (firstRunRatio === null) firstRunRatio = mean;
                        const label = sens.stability > 95 ? `<span class="text-lime-400 font-bold">[SPEED-INVARIANT]</span>` : `<span class="text-yellow-500 font-bold">[TEMPORAL ARTIFACT]</span>`;
                        epochSignatures.push({ id: `EPOCH-${simCount}`, ...generateSwarmSignature() });
                        artifacts.unshift({ id: `EPOCH-FLATLINE-${simCount}`, bounce: stats.bounces, tick: globalTick, desc: `DEEP THERMALIZATION: Quarter-million threshold exhausted.<br/>${label}<br/>Stability: ${sens.stability}% | Var: ${variance.toExponential(2)}`, trailAlpha: [...fleet[0].alpha.trail], trailBeta: [...fleet[0].beta.trail], kinematics: { alpha: {...fleet[0].alpha}, beta: {...fleet[0].beta} } });
                        simCount++; isEpochInverted = !isEpochInverted; if (!isEpochInverted) baseAngleShift += 1e-15;
                        fleet = initializeFleet(baseAngleShift, isEpochInverted);
                        epochBounces = 0; ratioHistory = []; speedHistory = []; recentRadii = [];
                    }
                }
            }

            // Sync UI & Dashboard
            if (swarmHit || globalTick % 20 === 0) {
                stats.windingNumber = fleet[0].alpha.accumulatedTheta / (2 * Math.PI);
                document.getElementById('statBounces').innerText = stats.bounces.toLocaleString();
                document.getElementById('statCorners').innerText = stats.cornerHits.toLocaleString();
                document.getElementById('statSim').innerText = `${simCount} / ${isEpochInverted ? 'TRUE' : 'FALSE'}`;
                document.getElementById('statInversions').innerText = inversionIncidences.toLocaleString();
                document.getElementById('statRecurrences').innerText = reEmergenceCount.toLocaleString();
                document.getElementById('statWinding').innerText = stats.windingNumber.toFixed(3);
                document.getElementById('statDivergence').innerText = maxDiv.toFixed(4);
                document.getElementById('val-epsilon').innerText = baseAngleShift.toExponential(2);
                
                // DEGREES OF FREEDOM & REALITY GAP MATH
                // Base DoF (14 particles * 4 states) + Memory DoF (Trail Length * 14 * 2)
                const activeDoF = (NUM_SWARMS * 2 * 4) + (NUM_SWARMS * 2 * trailLength * 2);
                const dofEl = document.getElementById('statDoF');
                if (dofEl) dofEl.innerText = activeDoF.toLocaleString();
                
                // Reality Gap Mapping (Exponential representation of necessary parallel sims to map constraints)
                const gapEl = document.getElementById('statGap');
                if (gapEl) {
                    const gap = Math.pow(10, activeDoF / 100);
                    gapEl.innerText = gap.toExponential(2) + " Sims";
                }

                const pr = document.getElementById('flatline-progress');
                if (pr) {
                    pr.style.width = `${Math.min(100, (epochBounces / flatlineBaseline) * 100)}%`;
                    pr.style.backgroundColor = epochBounces > 200000 ? '#4ade80' : '#eab308';
                }
                
                const vr = document.getElementById('val-variance');
                if (vr) vr.innerHTML = `DEPTH: ${(epochBounces/1000).toFixed(1)}k / 250k | VAR: ${ratioHistory.length ? "Scanning..." : "Syncing..."}`;
                
                const ratioEl = document.getElementById('val-ratio-current');
                if (ratioEl) ratioEl.innerText = ratioHistory.length ? ratioHistory[ratioHistory.length-1].toFixed(4) : "0.0000";
                const trendEl = document.getElementById('chaos-trend');
                if (trendEl && ratioHistory.length > 20) {
                    const recentAvg = ratioHistory.slice(-10).reduce((a,b)=>a+b,0)/10;
                    const oldAvg = ratioHistory.slice(0, 10).reduce((a,b)=>a+b,0)/10;
                    if (recentAvg > oldAvg * 1.05) { trendEl.innerText = "EMERGENCE TREND: â‡§ RE-EMERGING"; trendEl.className = "mt-1 text-center text-[10px] font-bold tracking-widest text-lime-400 bg-lime-900/20 p-1 rounded border border-lime-800/50"; } 
                    else if (recentAvg < oldAvg * 0.95) { trendEl.innerText = "EMERGENCE TREND: â‡© DEGRADING"; trendEl.className = "mt-1 text-center text-[10px] font-bold tracking-widest text-red-400 bg-red-900/20 p-1 rounded border border-red-800/50"; } 
                    else { trendEl.innerText = "EMERGENCE TREND: â‰ˆ STABLE"; trendEl.className = "mt-1 text-center text-[10px] font-bold tracking-widest text-cyan-400 bg-cyan-900/20 p-1 rounded border border-cyan-800/50"; }
                }

                if (stats.bounces % 2000 === 0) saveStateToCloud();
            }
        }

        // --- RENDER MAIN VIEWPORT ---
        function renderCanvas() {
            const canvas_el = document.getElementById('simCanvas');
            if(!canvas_el) return;
            const ctx_el = canvas_el.getContext('2d');
            const w = canvas_el.width, h = canvas_el.height, cx = w/2, cy = h/2, sc = Math.min(w,h)/2 * 0.9;
            ctx_el.fillStyle = 'rgba(0,0,0,0.8)'; ctx_el.fillRect(0,0,w,h);
            ctx_el.strokeStyle = '#33ff00'; ctx_el.lineWidth = 1; ctx_el.strokeRect(cx-sc, cy-sc, sc*2, sc*2);
            
            // Draw Multi-colored Age-Based Trails from the 7-color Palette
            const colorBatches = {};
            fleet.forEach(group => {
                [group.alpha, group.beta].forEach(agent => {
                    if (agent.trail.length > 1) {
                        for (let i = 1; i < agent.trail.length; i++) {
                            const color = getRuliadColorState(globalTick - agent.trail[i].tick);
                            if (!colorBatches[color]) colorBatches[color] = [];
                            colorBatches[color].push({ x1: cx + agent.trail[i-1].x * sc, y1: cy + agent.trail[i-1].y * sc, x2: cx + agent.trail[i].x * sc, y2: cy + agent.trail[i].y * sc });
                        }
                    }
                });
            });

            ctx_el.globalAlpha = 0.9; ctx_el.lineWidth = 2;
            for (const color in colorBatches) {
                ctx_el.beginPath();
                colorBatches[color].forEach(line => { ctx_el.moveTo(line.x1, line.y1); ctx_el.lineTo(line.x2, line.y2); });
                ctx_el.strokeStyle = color; ctx_el.stroke();
            }
            ctx_el.globalAlpha = 1.0;

            fleet.forEach(g => {
                ctx_el.beginPath(); ctx_el.arc(cx+g.alpha.x*sc, cy+g.alpha.y*sc, PARTICLE_RADIUS * sc, 0, Math.PI*2); ctx_el.fillStyle = '#fff'; ctx_el.fill();
                ctx_el.beginPath(); ctx_el.arc(cx+g.beta.x*sc, cy+g.beta.y*sc, PARTICLE_RADIUS * sc, 0, Math.PI*2); ctx_el.fillStyle = '#ff00ff'; ctx_el.fill();
            });

            // Ruliad Background CA Engine
            const bgC = document.getElementById('globalBgCanvas');
            if(bgC && bgCols > 0) {
                if (bgC.width !== window.innerWidth || bgC.height !== window.innerHeight) {
                    bgC.width = window.innerWidth; bgC.height = window.innerHeight;
                    initBgGrid(bgC.width, bgC.height);
                }
                const bCtx = bgC.getContext('2d'); 
                bCtx.fillStyle = 'rgba(0,0,0,0.4)'; bCtx.fillRect(0,0,bgC.width,bgC.height);
                for(let x=0; x<bgCols; x++) {
                    if (!bgGridCA[x]) continue;
                    for(let y=0; y<bgRows; y++) {
                        const s = bgGridCA[x][y]; 
                        // Render all 7 states for maximum Ruliad impact
                        bCtx.fillStyle = colorMapPalette[s]; 
                        bCtx.fillRect(x*25, y*25, 23, 23); 
                    }
                }
            }
        }

        // --- CLOUD SYNC & LEADERBOARD (Total Compute Storage) ---
        async function saveStateToCloud() {
            if (!supabaseClient || !currentUser || isSaving) return;
            isSaving = true; document.getElementById('save-status').innerText = 'SYNCING...';
            try {
                const s = { stats, simCount, epochBounces, isEpochInverted, baseAngleShift, speedHistory, firstRunRatio, inversionIncidences, reEmergenceCount, epochSignatures, initialFleetState, globalTick, artifacts, fleet: fleet.map(g => ({ alpha: { x: g.alpha.x, y: g.alpha.y, vx: g.alpha.vx, vy: g.alpha.vy }, beta: { x: g.beta.x, y: g.beta.y, vx: g.beta.vx, vy: g.beta.vy } })) };
                await supabaseClient.from('saves').upsert({ user_id: currentUser.uid, state_data: s });
                
                // Track Total Compute on Leaderboard
                let isGlobalTop = false;
                if (globalLeaderboard.length < 20) isGlobalTop = true;
                else if (stats.bounces > globalLeaderboard[globalLeaderboard.length - 1].bounce) isGlobalTop = true;

                if (isGlobalTop) {
                    // Update user's top score in the active leaderboard
                    const existingIndex = globalLeaderboard.findIndex(e => e.uid === currentUser.uid);
                    if (existingIndex !== -1) globalLeaderboard.splice(existingIndex, 1);
                    
                    globalLeaderboard.push({ uid: currentUser.uid, bounce: stats.bounces, timestamp: Date.now() });
                    globalLeaderboard.sort((a, b) => b.bounce - a.bounce);
                    if (globalLeaderboard.length > 20) globalLeaderboard.pop();
                    await supabaseClient.from('global_state').upsert({ id: 'main_leaderboard', leaderboard_data: { entries: globalLeaderboard } });
                }

                document.getElementById('save-status').innerText = 'DEEP SYNCED';
            } catch (e) { document.getElementById('save-status').innerText = 'OFFLINE'; }
            isSaving = false;
        }

        async function loadStateFromCloud() {
            if (!supabaseClient || !currentUser) return;
            try {
                const { data } = await supabaseClient.from('saves').select('state_data').eq('user_id', currentUser.uid).single();
                if (data && data.state_data) {
                    const s = data.state_data;
                    stats = s.stats || stats; simCount = s.simCount || 1; epochBounces = s.epochBounces || 0;
                    isEpochInverted = s.isEpochInverted || false; baseAngleShift = s.baseAngleShift || 0;
                    speedHistory = s.speedHistory || []; firstRunRatio = s.firstRunRatio !== undefined ? s.firstRunRatio : null;
                    inversionIncidences = s.inversionIncidences || 0; reEmergenceCount = s.reEmergenceCount || 0;
                    epochSignatures = s.epochSignatures || []; initialFleetState = s.initialFleetState || [];
                    artifacts = s.artifacts || []; globalTick = s.globalTick || 0;
                    if (s.fleet) fleet = s.fleet.map(g => ({ alpha: { ...g.alpha, trail: [] }, beta: { ...g.beta, trail: [] }, divergence: 0 }));
                    renderMuseum();
                }
            } catch (e) {}
        }

        async function setupGlobalLeaderboardListener() {
            if (!supabaseClient) return;
            const { data } = await supabaseClient.from('global_state').select('leaderboard_data').eq('id', 'main_leaderboard').single();
            if (data && data.leaderboard_data) {
                globalLeaderboard = data.leaderboard_data.entries || [];
                if (activeTab === 'RANK') renderLeaderboardUI();
            }
            supabaseClient.channel('public:global_state').on('postgres_changes', { event: '*', schema: 'public', table: 'global_state', filter: 'id=eq.main_leaderboard' }, payload => {
                if (payload.new && payload.new.leaderboard_data) {
                    globalLeaderboard = payload.new.leaderboard_data.entries || [];
                    if (activeTab === 'RANK') renderLeaderboardUI();
                }
            }).subscribe();
        }

        function renderLeaderboardUI() {
            const lc = document.getElementById('leaderboard-container');
            if (!lc) return;
            if (globalLeaderboard.length === 0) { lc.innerHTML = `<span class="text-gray-500">No configurations cataloged yet.</span>`; return; }
            lc.innerHTML = globalLeaderboard.map((entry, index) => {
                const isMe = currentUser && entry.uid === currentUser.uid;
                const displayUid = entry.uid.split('-')[0] + '...';
                return `
                <div class="flex flex-col border-b border-emerald-900/50 py-2 ${index === 0 ? 'bg-emerald-900/50 px-2 rounded border border-emerald-400' : ''} ${isMe ? 'border-l-4 border-l-lime-400 pl-2 bg-emerald-900/30' : ''}">
                    <div class="flex justify-between w-full items-center">
                        <div class="${index === 0 ? 'text-emerald-200 font-bold text-lg' : 'text-emerald-500'}">#${index + 1}</div>
                        <div class="text-[10px] text-gray-300 font-bold tracking-widest">${isMe ? '<span class="text-lime-400 drop-shadow-[0_0_5px_rgba(0,255,0,0.8)]">YOU</span>' : displayUid}</div>
                    </div>
                    <div class="font-bold text-xs text-lime-300 mt-1">${entry.bounce.toLocaleString()} Total Compute</div>
                </div>`
            }).join('');
        }

        // --- UI INTERACTIVITY ---
        window.switchTab = function(t) {
            activeTab = t; renderTabButtons();
            ['SUPER_BRAIN', 'EYES', 'STRUCTURE_RATIO', 'STABILITY', 'VOIDS', 'MUSEUM', 'HYPER', 'ZETA', 'RANK'].forEach(id => { const el = document.getElementById(`tab-${id}`); if(el) el.classList.add('hidden'); });
            const curr = document.getElementById(`tab-${t}`); 
            if(curr) { 
                curr.classList.remove('hidden'); 
                if(t==='MUSEUM') renderMuseum(); 
                if(t==='RANK') renderLeaderboardUI();
            }
        };

        function renderTabButtons() {
            const tabsList = ['SUPER_BRAIN', 'EYES', 'STRUCTURE_RATIO', 'STABILITY', 'VOIDS', 'MUSEUM', 'HYPER', 'ZETA', 'RANK'];
            document.getElementById('tab-headers').innerHTML = tabsList.map(t => `<button onclick="window.switchTab('${t}')" class="px-3 py-2 flex-shrink-0 transition-all ${activeTab === t ? 'bg-cyan-900/50 text-white border-t-2 border-cyan-400 font-bold shadow-[0_0_10px_rgba(0,255,255,0.5)]' : 'text-gray-400 hover:text-cyan-200'}">${t.replace('_', ' ')}</button>`).join('');
        }

        window.resetEngine = function() {
            simCount = 1; epochBounces = 0; inversionIncidences = 0; reEmergenceCount = 0; artifacts = []; epochSignatures = []; firstRunRatio = null; baseAngleShift = 0; fleet = initializeFleet(0, false); visitedGrid.clear(); hyperGrid.clear(); renderMuseum(); saveStateToCloud();
        };

        // --- MODAL REPLAY ---
        let modalArt = null, modalTick = 0, modalAnimId = null, modalLocalGrid = new Map();
        function playModal() {
            if (!modalArt) return;
            const c1 = document.getElementById('modalTrajCanvas'), c2 = document.getElementById('modalRuliadCanvas');
            const w = c1.width, h = c1.height, cx = w/2, cy = h/2, sc = Math.min(w,h)/2 * 0.9;
            const tCtx = c1.getContext('2d'), rCtx = c2.getContext('2d');
            
            if (modalTick === 0) { tCtx.fillStyle = '#050505'; tCtx.fillRect(0,0,w,h); rCtx.fillStyle = '#050505'; rCtx.fillRect(0,0,w,h); modalLocalGrid.clear(); tCtx.strokeStyle = '#33ff00'; tCtx.strokeRect(cx-sc, cy-sc, sc*2, sc*2); } 
            else { tCtx.fillStyle = 'rgba(5, 5, 5, 0.1)'; tCtx.fillRect(0, 0, w, h); tCtx.strokeStyle = '#33ff00'; tCtx.strokeRect(cx-sc, cy-sc, sc*2, sc*2); }
            
            const aT = modalArt.trailAlpha || [], bT = modalArt.trailBeta || [], max = Math.max(aT.length, bT.length);
            for (let k = 0; k < 200; k++) {
                if (modalTick < max) {
                    if (modalTick > 0 && modalTick < aT.length) { tCtx.beginPath(); tCtx.moveTo(cx+aT[modalTick-1].x*sc, cy+aT[modalTick-1].y*sc); tCtx.lineTo(cx+aT[modalTick].x*sc, cy+aT[modalTick].y*sc); tCtx.strokeStyle = '#00ffff'; tCtx.stroke(); modalLocalGrid.set(`${Math.floor(aT[modalTick].x*20)},${Math.floor(aT[modalTick].y*20)}`, modalTick); }
                    if (modalTick > 0 && modalTick < bT.length) { tCtx.beginPath(); tCtx.moveTo(cx+bT[modalTick-1].x*sc, cy+bT[modalTick-1].y*sc); tCtx.lineTo(cx+bT[modalTick].x*sc, cy+bT[modalTick].y*sc); tCtx.strokeStyle = '#ff00ff'; tCtx.stroke(); modalLocalGrid.set(`${Math.floor(bT[modalTick].x*20)},${Math.floor(bT[modalTick].y*20)}`, modalTick); }
                    rCtx.fillStyle = '#050505'; rCtx.fillRect(0, 0, w, h);
                    modalLocalGrid.forEach((vT, key) => { const [gx, gy] = key.split(',').map(Number); rCtx.fillStyle = getRuliadColorState((modalTick - vT)*3); rCtx.fillRect((gx/40)*w, (gy/40)*h, (w/40)-1, (h/40)-1); });
                    modalTick++;
                } else { modalTick = 0; break; }
            }
            modalAnimId = requestAnimationFrame(playModal);
        }

        window.openArtifactModal = (id) => {
            const art = artifacts.find(a => a.id === id); if(!art) return;
            modalArt = art; document.getElementById('modal-title').innerText = art.id; document.getElementById('modal-desc').innerHTML = art.desc;
            document.getElementById('artifactModal').classList.remove('hidden'); document.getElementById('artifactModal').classList.add('flex');
            const c1 = document.getElementById('modalTrajCanvas'); c1.width = c1.parentElement.clientWidth; c1.height = c1.parentElement.clientHeight;
            const c2 = document.getElementById('modalRuliadCanvas'); c2.width = c1.width; c2.height = c1.height;
            modalTick = 0; cancelAnimationFrame(modalAnimId); playModal();
        };
        window.closeModal = () => { cancelAnimationFrame(modalAnimId); document.getElementById('artifactModal').classList.add('hidden'); document.getElementById('artifactModal').classList.remove('flex'); };

        // --- MASTER LOOP WITH OVERCLOCK PROFILER ---
        function loopMain(timestamp) { 
            // FPS Tracking & Overclock unlocking
            frameCount++;
            if (timestamp - lastFpsTime >= 1000) {
                let currentFps = frameCount;
                frameCount = 0;
                lastFpsTime = timestamp;
                
                // If user's compute holds 55+ FPS while at max speed, unlock higher speeds for deeper data farming
                if (currentFps >= 55 && speed >= maxAllowedSpeed * 0.8 && maxAllowedSpeed < 1000) {
                    maxAllowedSpeed = Math.min(1000, maxAllowedSpeed * 2);
                    const speedInput = document.getElementById('speedInput');
                    if (speedInput) {
                        speedInput.max = maxAllowedSpeed;
                        document.getElementById('speedLabel').innerHTML = `x${speed} <span class="text-lime-400 text-[9px] animate-pulse absolute ml-2 mt-1">[OVERCLOCK UNLOCKED: ${maxAllowedSpeed}]</span>`;
                    }
                }
            }

            updatePhysics(); 
            renderCanvas(); 
            renderActiveTabCanvases(); // Constant 60fps refresh for dynamic UI canvases
            if(globalTick%5===0) updateBgGrid(); 
            requestAnimationFrame(loopMain); 
        }

        window.onload = async () => {
            initBgGrid(window.innerWidth, window.innerHeight);
            window.switchTab('STRUCTURE_RATIO'); // Default tab
            document.getElementById('speedInput').oninput = (e) => { speed = parseInt(e.target.value); document.getElementById('speedLabel').innerText = `x${speed}`; };
            document.getElementById('trailInput').oninput = (e) => { trailLength = parseInt(e.target.value); document.getElementById('trailLabel').innerText = `${trailLength} steps`; };

            try {
                const SUPABASE_URL = "https://xoolmbmnzbsvcqeyqvyi.supabase.co";
                const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhvb2xtYm1uemJzdmNxZXlxdnlpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE0NDMwNDQsImV4cCI6MjA4NzAxOTA0NH0.ebTwMZ_byU6EXtuR0jynct64QO5ornQrCwElQ5b9TxQ";
                supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                let uid = localStorage.getItem('ruliad_uid') || `USR-${crypto.randomUUID()}`;
                localStorage.setItem('ruliad_uid', uid); currentUser = { uid };
                await loadStateFromCloud();
                await setupGlobalLeaderboardListener();
                document.getElementById('save-status').innerText = 'READY';
                document.getElementById('save-status').className = 'text-lime-500 font-bold';
            } catch (e) { document.getElementById('save-status').innerText = 'LOCAL'; }
            
            requestAnimationFrame(loopMain); // IGNITION
        };
    </script>
</body>
</html>